9.9 通道（channel）

通道是一个类型管道，通过它可以通过通道运算符发送和接收值`<-`。

Go依赖于称为CSP（Communicating Sequential Processes）的并发模型，通过Channel实现这种同步模式。Go并发的核心哲学是不要通过共享内存进行通信; 相反，通过沟通分享记忆。

下面以简单的示例来说明Go如何通过channel来实现通信。

```
package main
import (
	"fmt"
	"time"
)
func goRoutineA(a <-chan int) {
	val := <-a
	fmt.Println("goRoutineA received the data", val)
}
func goRoutineB(b chan int) {
	val := <-b
	fmt.Println("goRoutineB  received the data", val)
}
func main() {
	ch := make(chan int, 3)
	go goRoutineA(ch)
	go goRoutineB(ch)
	ch <- 3
	time.Sleep(time.Second * 1)
}

```









大概流程

![](https://github.com/guyan0319/golang_development_notes/blob/master/images/9.9.1.png?raw=true)

因此，Go中的通道的责任是使Goroutine再次可运行，在接收数据或发送数据时在通道上被阻塞。

如果您对Go调度不熟悉，请参考这篇文章

https://github.com/guyan0319/golang_development_notes/blob/master/zh/9.5.md

hchan 结构(源代码src/runtime/chan.go)

```
hchan struct {
	qcount uint : 0 
	dataqsiz uint : 3 
	buf unsafe.Pointer : 0xc00007e0e0 
	elemsize uint16 : 8 
	closed uint32 : 0 
	elemtype *runtime._type : 
		&{
		size:8 
		ptrdata:0 
		hash:4149441018 
		tflag:7 
		align:8 
		fieldalign:8 
		kind:130 
		alg:0x55cdf0 
		gcdata:0x4d61b4 
		str:1055 
		ptrToThis:45152
		}
	sendx uint : 0 
	recvx uint : 0 
	recvq runtime.waitq : 
		{first:<nil> last:<nil>}
	sendq runtime.waitq : 
		{first:<nil> last:<nil>}
	lock runtime.mutex : 
		{key:0}
}
```







## links

- [目录](https://github.com/guyan0319/golang_development_notes/blob/master/zh/preface.md)
- 上一节：
- 下一节：

